// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'moneygram.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
mixin _$MoneygramChallengeSignRequestDto {
  String get signedTx;

  /// Create a copy of MoneygramChallengeSignRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MoneygramChallengeSignRequestDtoCopyWith<MoneygramChallengeSignRequestDto> get copyWith =>
      _$MoneygramChallengeSignRequestDtoCopyWithImpl<MoneygramChallengeSignRequestDto>(
        this as MoneygramChallengeSignRequestDto,
        _$identity,
      );

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MoneygramChallengeSignRequestDto &&
            (identical(other.signedTx, signedTx) || other.signedTx == signedTx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, signedTx);

  @override
  String toString() {
    return 'MoneygramChallengeSignRequestDto(signedTx: $signedTx)';
  }
}

/// @nodoc
abstract mixin class $MoneygramChallengeSignRequestDtoCopyWith<$Res> {
  factory $MoneygramChallengeSignRequestDtoCopyWith(
    MoneygramChallengeSignRequestDto value,
    $Res Function(MoneygramChallengeSignRequestDto) _then,
  ) = _$MoneygramChallengeSignRequestDtoCopyWithImpl;
  @useResult
  $Res call({String signedTx});
}

/// @nodoc
class _$MoneygramChallengeSignRequestDtoCopyWithImpl<$Res>
    implements $MoneygramChallengeSignRequestDtoCopyWith<$Res> {
  _$MoneygramChallengeSignRequestDtoCopyWithImpl(this._self, this._then);

  final MoneygramChallengeSignRequestDto _self;
  final $Res Function(MoneygramChallengeSignRequestDto) _then;

  /// Create a copy of MoneygramChallengeSignRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? signedTx = null}) {
    return _then(
      _self.copyWith(
        signedTx:
            null == signedTx
                ? _self.signedTx
                : signedTx // ignore: cast_nullable_to_non_nullable
                    as String,
      ),
    );
  }
}

/// @nodoc

class _MoneygramChallengeSignRequestDto implements MoneygramChallengeSignRequestDto {
  const _MoneygramChallengeSignRequestDto({required this.signedTx});

  @override
  final String signedTx;

  /// Create a copy of MoneygramChallengeSignRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MoneygramChallengeSignRequestDtoCopyWith<_MoneygramChallengeSignRequestDto> get copyWith =>
      __$MoneygramChallengeSignRequestDtoCopyWithImpl<_MoneygramChallengeSignRequestDto>(
        this,
        _$identity,
      );

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MoneygramChallengeSignRequestDto &&
            (identical(other.signedTx, signedTx) || other.signedTx == signedTx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, signedTx);

  @override
  String toString() {
    return 'MoneygramChallengeSignRequestDto(signedTx: $signedTx)';
  }
}

/// @nodoc
abstract mixin class _$MoneygramChallengeSignRequestDtoCopyWith<$Res>
    implements $MoneygramChallengeSignRequestDtoCopyWith<$Res> {
  factory _$MoneygramChallengeSignRequestDtoCopyWith(
    _MoneygramChallengeSignRequestDto value,
    $Res Function(_MoneygramChallengeSignRequestDto) _then,
  ) = __$MoneygramChallengeSignRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call({String signedTx});
}

/// @nodoc
class __$MoneygramChallengeSignRequestDtoCopyWithImpl<$Res>
    implements _$MoneygramChallengeSignRequestDtoCopyWith<$Res> {
  __$MoneygramChallengeSignRequestDtoCopyWithImpl(this._self, this._then);

  final _MoneygramChallengeSignRequestDto _self;
  final $Res Function(_MoneygramChallengeSignRequestDto) _then;

  /// Create a copy of MoneygramChallengeSignRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({Object? signedTx = null}) {
    return _then(
      _MoneygramChallengeSignRequestDto(
        signedTx:
            null == signedTx
                ? _self.signedTx
                : signedTx // ignore: cast_nullable_to_non_nullable
                    as String,
      ),
    );
  }
}

/// @nodoc
mixin _$MoneygramChallengeSignResponseDto {
  String get signedTx;

  /// Create a copy of MoneygramChallengeSignResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MoneygramChallengeSignResponseDtoCopyWith<MoneygramChallengeSignResponseDto> get copyWith =>
      _$MoneygramChallengeSignResponseDtoCopyWithImpl<MoneygramChallengeSignResponseDto>(
        this as MoneygramChallengeSignResponseDto,
        _$identity,
      );

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MoneygramChallengeSignResponseDto &&
            (identical(other.signedTx, signedTx) || other.signedTx == signedTx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, signedTx);

  @override
  String toString() {
    return 'MoneygramChallengeSignResponseDto(signedTx: $signedTx)';
  }
}

/// @nodoc
abstract mixin class $MoneygramChallengeSignResponseDtoCopyWith<$Res> {
  factory $MoneygramChallengeSignResponseDtoCopyWith(
    MoneygramChallengeSignResponseDto value,
    $Res Function(MoneygramChallengeSignResponseDto) _then,
  ) = _$MoneygramChallengeSignResponseDtoCopyWithImpl;
  @useResult
  $Res call({String signedTx});
}

/// @nodoc
class _$MoneygramChallengeSignResponseDtoCopyWithImpl<$Res>
    implements $MoneygramChallengeSignResponseDtoCopyWith<$Res> {
  _$MoneygramChallengeSignResponseDtoCopyWithImpl(this._self, this._then);

  final MoneygramChallengeSignResponseDto _self;
  final $Res Function(MoneygramChallengeSignResponseDto) _then;

  /// Create a copy of MoneygramChallengeSignResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? signedTx = null}) {
    return _then(
      _self.copyWith(
        signedTx:
            null == signedTx
                ? _self.signedTx
                : signedTx // ignore: cast_nullable_to_non_nullable
                    as String,
      ),
    );
  }
}

/// @nodoc

class _MoneygramChallengeSignResponseDto implements MoneygramChallengeSignResponseDto {
  const _MoneygramChallengeSignResponseDto({required this.signedTx});

  @override
  final String signedTx;

  /// Create a copy of MoneygramChallengeSignResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MoneygramChallengeSignResponseDtoCopyWith<_MoneygramChallengeSignResponseDto> get copyWith =>
      __$MoneygramChallengeSignResponseDtoCopyWithImpl<_MoneygramChallengeSignResponseDto>(
        this,
        _$identity,
      );

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MoneygramChallengeSignResponseDto &&
            (identical(other.signedTx, signedTx) || other.signedTx == signedTx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, signedTx);

  @override
  String toString() {
    return 'MoneygramChallengeSignResponseDto(signedTx: $signedTx)';
  }
}

/// @nodoc
abstract mixin class _$MoneygramChallengeSignResponseDtoCopyWith<$Res>
    implements $MoneygramChallengeSignResponseDtoCopyWith<$Res> {
  factory _$MoneygramChallengeSignResponseDtoCopyWith(
    _MoneygramChallengeSignResponseDto value,
    $Res Function(_MoneygramChallengeSignResponseDto) _then,
  ) = __$MoneygramChallengeSignResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call({String signedTx});
}

/// @nodoc
class __$MoneygramChallengeSignResponseDtoCopyWithImpl<$Res>
    implements _$MoneygramChallengeSignResponseDtoCopyWith<$Res> {
  __$MoneygramChallengeSignResponseDtoCopyWithImpl(this._self, this._then);

  final _MoneygramChallengeSignResponseDto _self;
  final $Res Function(_MoneygramChallengeSignResponseDto) _then;

  /// Create a copy of MoneygramChallengeSignResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({Object? signedTx = null}) {
    return _then(
      _MoneygramChallengeSignResponseDto(
        signedTx:
            null == signedTx
                ? _self.signedTx
                : signedTx // ignore: cast_nullable_to_non_nullable
                    as String,
      ),
    );
  }
}

/// @nodoc
mixin _$SwapToStellarRequestDto {
  String get solanaSenderAddress;
  String get stellarReceiverAddress;
  String get amount;
  int? get priorityFee;

  /// Create a copy of SwapToStellarRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SwapToStellarRequestDtoCopyWith<SwapToStellarRequestDto> get copyWith =>
      _$SwapToStellarRequestDtoCopyWithImpl<SwapToStellarRequestDto>(
        this as SwapToStellarRequestDto,
        _$identity,
      );

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SwapToStellarRequestDto &&
            (identical(other.solanaSenderAddress, solanaSenderAddress) ||
                other.solanaSenderAddress == solanaSenderAddress) &&
            (identical(other.stellarReceiverAddress, stellarReceiverAddress) ||
                other.stellarReceiverAddress == stellarReceiverAddress) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.priorityFee, priorityFee) || other.priorityFee == priorityFee));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, solanaSenderAddress, stellarReceiverAddress, amount, priorityFee);

  @override
  String toString() {
    return 'SwapToStellarRequestDto(solanaSenderAddress: $solanaSenderAddress, stellarReceiverAddress: $stellarReceiverAddress, amount: $amount, priorityFee: $priorityFee)';
  }
}

/// @nodoc
abstract mixin class $SwapToStellarRequestDtoCopyWith<$Res> {
  factory $SwapToStellarRequestDtoCopyWith(
    SwapToStellarRequestDto value,
    $Res Function(SwapToStellarRequestDto) _then,
  ) = _$SwapToStellarRequestDtoCopyWithImpl;
  @useResult
  $Res call({
    String solanaSenderAddress,
    String stellarReceiverAddress,
    String amount,
    int? priorityFee,
  });
}

/// @nodoc
class _$SwapToStellarRequestDtoCopyWithImpl<$Res>
    implements $SwapToStellarRequestDtoCopyWith<$Res> {
  _$SwapToStellarRequestDtoCopyWithImpl(this._self, this._then);

  final SwapToStellarRequestDto _self;
  final $Res Function(SwapToStellarRequestDto) _then;

  /// Create a copy of SwapToStellarRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? solanaSenderAddress = null,
    Object? stellarReceiverAddress = null,
    Object? amount = null,
    Object? priorityFee = freezed,
  }) {
    return _then(
      _self.copyWith(
        solanaSenderAddress:
            null == solanaSenderAddress
                ? _self.solanaSenderAddress
                : solanaSenderAddress // ignore: cast_nullable_to_non_nullable
                    as String,
        stellarReceiverAddress:
            null == stellarReceiverAddress
                ? _self.stellarReceiverAddress
                : stellarReceiverAddress // ignore: cast_nullable_to_non_nullable
                    as String,
        amount:
            null == amount
                ? _self.amount
                : amount // ignore: cast_nullable_to_non_nullable
                    as String,
        priorityFee:
            freezed == priorityFee
                ? _self.priorityFee
                : priorityFee // ignore: cast_nullable_to_non_nullable
                    as int?,
      ),
    );
  }
}

/// @nodoc

class _SwapToStellarRequestDto implements SwapToStellarRequestDto {
  const _SwapToStellarRequestDto({
    required this.solanaSenderAddress,
    required this.stellarReceiverAddress,
    required this.amount,
    this.priorityFee,
  });

  @override
  final String solanaSenderAddress;
  @override
  final String stellarReceiverAddress;
  @override
  final String amount;
  @override
  final int? priorityFee;

  /// Create a copy of SwapToStellarRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$SwapToStellarRequestDtoCopyWith<_SwapToStellarRequestDto> get copyWith =>
      __$SwapToStellarRequestDtoCopyWithImpl<_SwapToStellarRequestDto>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SwapToStellarRequestDto &&
            (identical(other.solanaSenderAddress, solanaSenderAddress) ||
                other.solanaSenderAddress == solanaSenderAddress) &&
            (identical(other.stellarReceiverAddress, stellarReceiverAddress) ||
                other.stellarReceiverAddress == stellarReceiverAddress) &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.priorityFee, priorityFee) || other.priorityFee == priorityFee));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, solanaSenderAddress, stellarReceiverAddress, amount, priorityFee);

  @override
  String toString() {
    return 'SwapToStellarRequestDto(solanaSenderAddress: $solanaSenderAddress, stellarReceiverAddress: $stellarReceiverAddress, amount: $amount, priorityFee: $priorityFee)';
  }
}

/// @nodoc
abstract mixin class _$SwapToStellarRequestDtoCopyWith<$Res>
    implements $SwapToStellarRequestDtoCopyWith<$Res> {
  factory _$SwapToStellarRequestDtoCopyWith(
    _SwapToStellarRequestDto value,
    $Res Function(_SwapToStellarRequestDto) _then,
  ) = __$SwapToStellarRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call({
    String solanaSenderAddress,
    String stellarReceiverAddress,
    String amount,
    int? priorityFee,
  });
}

/// @nodoc
class __$SwapToStellarRequestDtoCopyWithImpl<$Res>
    implements _$SwapToStellarRequestDtoCopyWith<$Res> {
  __$SwapToStellarRequestDtoCopyWithImpl(this._self, this._then);

  final _SwapToStellarRequestDto _self;
  final $Res Function(_SwapToStellarRequestDto) _then;

  /// Create a copy of SwapToStellarRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? solanaSenderAddress = null,
    Object? stellarReceiverAddress = null,
    Object? amount = null,
    Object? priorityFee = freezed,
  }) {
    return _then(
      _SwapToStellarRequestDto(
        solanaSenderAddress:
            null == solanaSenderAddress
                ? _self.solanaSenderAddress
                : solanaSenderAddress // ignore: cast_nullable_to_non_nullable
                    as String,
        stellarReceiverAddress:
            null == stellarReceiverAddress
                ? _self.stellarReceiverAddress
                : stellarReceiverAddress // ignore: cast_nullable_to_non_nullable
                    as String,
        amount:
            null == amount
                ? _self.amount
                : amount // ignore: cast_nullable_to_non_nullable
                    as String,
        priorityFee:
            freezed == priorityFee
                ? _self.priorityFee
                : priorityFee // ignore: cast_nullable_to_non_nullable
                    as int?,
      ),
    );
  }
}

/// @nodoc
mixin _$SwapToSolanaRequestDto {
  String get stellarSenderAddress;
  String get solanaReceiverAddress;
  String get amount;

  /// Create a copy of SwapToSolanaRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SwapToSolanaRequestDtoCopyWith<SwapToSolanaRequestDto> get copyWith =>
      _$SwapToSolanaRequestDtoCopyWithImpl<SwapToSolanaRequestDto>(
        this as SwapToSolanaRequestDto,
        _$identity,
      );

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SwapToSolanaRequestDto &&
            (identical(other.stellarSenderAddress, stellarSenderAddress) ||
                other.stellarSenderAddress == stellarSenderAddress) &&
            (identical(other.solanaReceiverAddress, solanaReceiverAddress) ||
                other.solanaReceiverAddress == solanaReceiverAddress) &&
            (identical(other.amount, amount) || other.amount == amount));
  }

  @override
  int get hashCode => Object.hash(runtimeType, stellarSenderAddress, solanaReceiverAddress, amount);

  @override
  String toString() {
    return 'SwapToSolanaRequestDto(stellarSenderAddress: $stellarSenderAddress, solanaReceiverAddress: $solanaReceiverAddress, amount: $amount)';
  }
}

/// @nodoc
abstract mixin class $SwapToSolanaRequestDtoCopyWith<$Res> {
  factory $SwapToSolanaRequestDtoCopyWith(
    SwapToSolanaRequestDto value,
    $Res Function(SwapToSolanaRequestDto) _then,
  ) = _$SwapToSolanaRequestDtoCopyWithImpl;
  @useResult
  $Res call({String stellarSenderAddress, String solanaReceiverAddress, String amount});
}

/// @nodoc
class _$SwapToSolanaRequestDtoCopyWithImpl<$Res> implements $SwapToSolanaRequestDtoCopyWith<$Res> {
  _$SwapToSolanaRequestDtoCopyWithImpl(this._self, this._then);

  final SwapToSolanaRequestDto _self;
  final $Res Function(SwapToSolanaRequestDto) _then;

  /// Create a copy of SwapToSolanaRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stellarSenderAddress = null,
    Object? solanaReceiverAddress = null,
    Object? amount = null,
  }) {
    return _then(
      _self.copyWith(
        stellarSenderAddress:
            null == stellarSenderAddress
                ? _self.stellarSenderAddress
                : stellarSenderAddress // ignore: cast_nullable_to_non_nullable
                    as String,
        solanaReceiverAddress:
            null == solanaReceiverAddress
                ? _self.solanaReceiverAddress
                : solanaReceiverAddress // ignore: cast_nullable_to_non_nullable
                    as String,
        amount:
            null == amount
                ? _self.amount
                : amount // ignore: cast_nullable_to_non_nullable
                    as String,
      ),
    );
  }
}

/// @nodoc

class _SwapToSolanaRequestDto implements SwapToSolanaRequestDto {
  const _SwapToSolanaRequestDto({
    required this.stellarSenderAddress,
    required this.solanaReceiverAddress,
    required this.amount,
  });

  @override
  final String stellarSenderAddress;
  @override
  final String solanaReceiverAddress;
  @override
  final String amount;

  /// Create a copy of SwapToSolanaRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$SwapToSolanaRequestDtoCopyWith<_SwapToSolanaRequestDto> get copyWith =>
      __$SwapToSolanaRequestDtoCopyWithImpl<_SwapToSolanaRequestDto>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _SwapToSolanaRequestDto &&
            (identical(other.stellarSenderAddress, stellarSenderAddress) ||
                other.stellarSenderAddress == stellarSenderAddress) &&
            (identical(other.solanaReceiverAddress, solanaReceiverAddress) ||
                other.solanaReceiverAddress == solanaReceiverAddress) &&
            (identical(other.amount, amount) || other.amount == amount));
  }

  @override
  int get hashCode => Object.hash(runtimeType, stellarSenderAddress, solanaReceiverAddress, amount);

  @override
  String toString() {
    return 'SwapToSolanaRequestDto(stellarSenderAddress: $stellarSenderAddress, solanaReceiverAddress: $solanaReceiverAddress, amount: $amount)';
  }
}

/// @nodoc
abstract mixin class _$SwapToSolanaRequestDtoCopyWith<$Res>
    implements $SwapToSolanaRequestDtoCopyWith<$Res> {
  factory _$SwapToSolanaRequestDtoCopyWith(
    _SwapToSolanaRequestDto value,
    $Res Function(_SwapToSolanaRequestDto) _then,
  ) = __$SwapToSolanaRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call({String stellarSenderAddress, String solanaReceiverAddress, String amount});
}

/// @nodoc
class __$SwapToSolanaRequestDtoCopyWithImpl<$Res>
    implements _$SwapToSolanaRequestDtoCopyWith<$Res> {
  __$SwapToSolanaRequestDtoCopyWithImpl(this._self, this._then);

  final _SwapToSolanaRequestDto _self;
  final $Res Function(_SwapToSolanaRequestDto) _then;

  /// Create a copy of SwapToSolanaRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? stellarSenderAddress = null,
    Object? solanaReceiverAddress = null,
    Object? amount = null,
  }) {
    return _then(
      _SwapToSolanaRequestDto(
        stellarSenderAddress:
            null == stellarSenderAddress
                ? _self.stellarSenderAddress
                : stellarSenderAddress // ignore: cast_nullable_to_non_nullable
                    as String,
        solanaReceiverAddress:
            null == solanaReceiverAddress
                ? _self.solanaReceiverAddress
                : solanaReceiverAddress // ignore: cast_nullable_to_non_nullable
                    as String,
        amount:
            null == amount
                ? _self.amount
                : amount // ignore: cast_nullable_to_non_nullable
                    as String,
      ),
    );
  }
}

/// @nodoc
mixin _$MoneygramSwapResponseDto {
  String get encodedTx;

  /// Create a copy of MoneygramSwapResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MoneygramSwapResponseDtoCopyWith<MoneygramSwapResponseDto> get copyWith =>
      _$MoneygramSwapResponseDtoCopyWithImpl<MoneygramSwapResponseDto>(
        this as MoneygramSwapResponseDto,
        _$identity,
      );

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MoneygramSwapResponseDto &&
            (identical(other.encodedTx, encodedTx) || other.encodedTx == encodedTx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, encodedTx);

  @override
  String toString() {
    return 'MoneygramSwapResponseDto(encodedTx: $encodedTx)';
  }
}

/// @nodoc
abstract mixin class $MoneygramSwapResponseDtoCopyWith<$Res> {
  factory $MoneygramSwapResponseDtoCopyWith(
    MoneygramSwapResponseDto value,
    $Res Function(MoneygramSwapResponseDto) _then,
  ) = _$MoneygramSwapResponseDtoCopyWithImpl;
  @useResult
  $Res call({String encodedTx});
}

/// @nodoc
class _$MoneygramSwapResponseDtoCopyWithImpl<$Res>
    implements $MoneygramSwapResponseDtoCopyWith<$Res> {
  _$MoneygramSwapResponseDtoCopyWithImpl(this._self, this._then);

  final MoneygramSwapResponseDto _self;
  final $Res Function(MoneygramSwapResponseDto) _then;

  /// Create a copy of MoneygramSwapResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? encodedTx = null}) {
    return _then(
      _self.copyWith(
        encodedTx:
            null == encodedTx
                ? _self.encodedTx
                : encodedTx // ignore: cast_nullable_to_non_nullable
                    as String,
      ),
    );
  }
}

/// @nodoc

class _MoneygramSwapResponseDto implements MoneygramSwapResponseDto {
  const _MoneygramSwapResponseDto({required this.encodedTx});

  @override
  final String encodedTx;

  /// Create a copy of MoneygramSwapResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MoneygramSwapResponseDtoCopyWith<_MoneygramSwapResponseDto> get copyWith =>
      __$MoneygramSwapResponseDtoCopyWithImpl<_MoneygramSwapResponseDto>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MoneygramSwapResponseDto &&
            (identical(other.encodedTx, encodedTx) || other.encodedTx == encodedTx));
  }

  @override
  int get hashCode => Object.hash(runtimeType, encodedTx);

  @override
  String toString() {
    return 'MoneygramSwapResponseDto(encodedTx: $encodedTx)';
  }
}

/// @nodoc
abstract mixin class _$MoneygramSwapResponseDtoCopyWith<$Res>
    implements $MoneygramSwapResponseDtoCopyWith<$Res> {
  factory _$MoneygramSwapResponseDtoCopyWith(
    _MoneygramSwapResponseDto value,
    $Res Function(_MoneygramSwapResponseDto) _then,
  ) = __$MoneygramSwapResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call({String encodedTx});
}

/// @nodoc
class __$MoneygramSwapResponseDtoCopyWithImpl<$Res>
    implements _$MoneygramSwapResponseDtoCopyWith<$Res> {
  __$MoneygramSwapResponseDtoCopyWithImpl(this._self, this._then);

  final _MoneygramSwapResponseDto _self;
  final $Res Function(_MoneygramSwapResponseDto) _then;

  /// Create a copy of MoneygramSwapResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({Object? encodedTx = null}) {
    return _then(
      _MoneygramSwapResponseDto(
        encodedTx:
            null == encodedTx
                ? _self.encodedTx
                : encodedTx // ignore: cast_nullable_to_non_nullable
                    as String,
      ),
    );
  }
}

/// @nodoc
mixin _$MoneygramFeeRequestDto {
  String get amount;
  RampTypeDto get type;

  /// Create a copy of MoneygramFeeRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MoneygramFeeRequestDtoCopyWith<MoneygramFeeRequestDto> get copyWith =>
      _$MoneygramFeeRequestDtoCopyWithImpl<MoneygramFeeRequestDto>(
        this as MoneygramFeeRequestDto,
        _$identity,
      );

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MoneygramFeeRequestDto &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, amount, type);

  @override
  String toString() {
    return 'MoneygramFeeRequestDto(amount: $amount, type: $type)';
  }
}

/// @nodoc
abstract mixin class $MoneygramFeeRequestDtoCopyWith<$Res> {
  factory $MoneygramFeeRequestDtoCopyWith(
    MoneygramFeeRequestDto value,
    $Res Function(MoneygramFeeRequestDto) _then,
  ) = _$MoneygramFeeRequestDtoCopyWithImpl;
  @useResult
  $Res call({String amount, RampTypeDto type});
}

/// @nodoc
class _$MoneygramFeeRequestDtoCopyWithImpl<$Res> implements $MoneygramFeeRequestDtoCopyWith<$Res> {
  _$MoneygramFeeRequestDtoCopyWithImpl(this._self, this._then);

  final MoneygramFeeRequestDto _self;
  final $Res Function(MoneygramFeeRequestDto) _then;

  /// Create a copy of MoneygramFeeRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? amount = null, Object? type = null}) {
    return _then(
      _self.copyWith(
        amount:
            null == amount
                ? _self.amount
                : amount // ignore: cast_nullable_to_non_nullable
                    as String,
        type:
            null == type
                ? _self.type
                : type // ignore: cast_nullable_to_non_nullable
                    as RampTypeDto,
      ),
    );
  }
}

/// @nodoc

class _MoneygramFeeRequestDto implements MoneygramFeeRequestDto {
  const _MoneygramFeeRequestDto({required this.amount, required this.type});

  @override
  final String amount;
  @override
  final RampTypeDto type;

  /// Create a copy of MoneygramFeeRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MoneygramFeeRequestDtoCopyWith<_MoneygramFeeRequestDto> get copyWith =>
      __$MoneygramFeeRequestDtoCopyWithImpl<_MoneygramFeeRequestDto>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MoneygramFeeRequestDto &&
            (identical(other.amount, amount) || other.amount == amount) &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, amount, type);

  @override
  String toString() {
    return 'MoneygramFeeRequestDto(amount: $amount, type: $type)';
  }
}

/// @nodoc
abstract mixin class _$MoneygramFeeRequestDtoCopyWith<$Res>
    implements $MoneygramFeeRequestDtoCopyWith<$Res> {
  factory _$MoneygramFeeRequestDtoCopyWith(
    _MoneygramFeeRequestDto value,
    $Res Function(_MoneygramFeeRequestDto) _then,
  ) = __$MoneygramFeeRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call({String amount, RampTypeDto type});
}

/// @nodoc
class __$MoneygramFeeRequestDtoCopyWithImpl<$Res>
    implements _$MoneygramFeeRequestDtoCopyWith<$Res> {
  __$MoneygramFeeRequestDtoCopyWithImpl(this._self, this._then);

  final _MoneygramFeeRequestDto _self;
  final $Res Function(_MoneygramFeeRequestDto) _then;

  /// Create a copy of MoneygramFeeRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({Object? amount = null, Object? type = null}) {
    return _then(
      _MoneygramFeeRequestDto(
        amount:
            null == amount
                ? _self.amount
                : amount // ignore: cast_nullable_to_non_nullable
                    as String,
        type:
            null == type
                ? _self.type
                : type // ignore: cast_nullable_to_non_nullable
                    as RampTypeDto,
      ),
    );
  }
}

/// @nodoc
mixin _$MoneygramFeeResponseDto {
  String get bridgeFee;
  String get moneygramFee;
  String? get gasFeeInUsdc;
  int? get priorityFee;

  /// Create a copy of MoneygramFeeResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $MoneygramFeeResponseDtoCopyWith<MoneygramFeeResponseDto> get copyWith =>
      _$MoneygramFeeResponseDtoCopyWithImpl<MoneygramFeeResponseDto>(
        this as MoneygramFeeResponseDto,
        _$identity,
      );

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is MoneygramFeeResponseDto &&
            (identical(other.bridgeFee, bridgeFee) || other.bridgeFee == bridgeFee) &&
            (identical(other.moneygramFee, moneygramFee) || other.moneygramFee == moneygramFee) &&
            (identical(other.gasFeeInUsdc, gasFeeInUsdc) || other.gasFeeInUsdc == gasFeeInUsdc) &&
            (identical(other.priorityFee, priorityFee) || other.priorityFee == priorityFee));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bridgeFee, moneygramFee, gasFeeInUsdc, priorityFee);

  @override
  String toString() {
    return 'MoneygramFeeResponseDto(bridgeFee: $bridgeFee, moneygramFee: $moneygramFee, gasFeeInUsdc: $gasFeeInUsdc, priorityFee: $priorityFee)';
  }
}

/// @nodoc
abstract mixin class $MoneygramFeeResponseDtoCopyWith<$Res> {
  factory $MoneygramFeeResponseDtoCopyWith(
    MoneygramFeeResponseDto value,
    $Res Function(MoneygramFeeResponseDto) _then,
  ) = _$MoneygramFeeResponseDtoCopyWithImpl;
  @useResult
  $Res call({String bridgeFee, String moneygramFee, String? gasFeeInUsdc, int? priorityFee});
}

/// @nodoc
class _$MoneygramFeeResponseDtoCopyWithImpl<$Res>
    implements $MoneygramFeeResponseDtoCopyWith<$Res> {
  _$MoneygramFeeResponseDtoCopyWithImpl(this._self, this._then);

  final MoneygramFeeResponseDto _self;
  final $Res Function(MoneygramFeeResponseDto) _then;

  /// Create a copy of MoneygramFeeResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bridgeFee = null,
    Object? moneygramFee = null,
    Object? gasFeeInUsdc = freezed,
    Object? priorityFee = freezed,
  }) {
    return _then(
      _self.copyWith(
        bridgeFee:
            null == bridgeFee
                ? _self.bridgeFee
                : bridgeFee // ignore: cast_nullable_to_non_nullable
                    as String,
        moneygramFee:
            null == moneygramFee
                ? _self.moneygramFee
                : moneygramFee // ignore: cast_nullable_to_non_nullable
                    as String,
        gasFeeInUsdc:
            freezed == gasFeeInUsdc
                ? _self.gasFeeInUsdc
                : gasFeeInUsdc // ignore: cast_nullable_to_non_nullable
                    as String?,
        priorityFee:
            freezed == priorityFee
                ? _self.priorityFee
                : priorityFee // ignore: cast_nullable_to_non_nullable
                    as int?,
      ),
    );
  }
}

/// @nodoc

class _MoneygramFeeResponseDto implements MoneygramFeeResponseDto {
  const _MoneygramFeeResponseDto({
    required this.bridgeFee,
    required this.moneygramFee,
    this.gasFeeInUsdc,
    this.priorityFee,
  });

  @override
  final String bridgeFee;
  @override
  final String moneygramFee;
  @override
  final String? gasFeeInUsdc;
  @override
  final int? priorityFee;

  /// Create a copy of MoneygramFeeResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$MoneygramFeeResponseDtoCopyWith<_MoneygramFeeResponseDto> get copyWith =>
      __$MoneygramFeeResponseDtoCopyWithImpl<_MoneygramFeeResponseDto>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _MoneygramFeeResponseDto &&
            (identical(other.bridgeFee, bridgeFee) || other.bridgeFee == bridgeFee) &&
            (identical(other.moneygramFee, moneygramFee) || other.moneygramFee == moneygramFee) &&
            (identical(other.gasFeeInUsdc, gasFeeInUsdc) || other.gasFeeInUsdc == gasFeeInUsdc) &&
            (identical(other.priorityFee, priorityFee) || other.priorityFee == priorityFee));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bridgeFee, moneygramFee, gasFeeInUsdc, priorityFee);

  @override
  String toString() {
    return 'MoneygramFeeResponseDto(bridgeFee: $bridgeFee, moneygramFee: $moneygramFee, gasFeeInUsdc: $gasFeeInUsdc, priorityFee: $priorityFee)';
  }
}

/// @nodoc
abstract mixin class _$MoneygramFeeResponseDtoCopyWith<$Res>
    implements $MoneygramFeeResponseDtoCopyWith<$Res> {
  factory _$MoneygramFeeResponseDtoCopyWith(
    _MoneygramFeeResponseDto value,
    $Res Function(_MoneygramFeeResponseDto) _then,
  ) = __$MoneygramFeeResponseDtoCopyWithImpl;
  @override
  @useResult
  $Res call({String bridgeFee, String moneygramFee, String? gasFeeInUsdc, int? priorityFee});
}

/// @nodoc
class __$MoneygramFeeResponseDtoCopyWithImpl<$Res>
    implements _$MoneygramFeeResponseDtoCopyWith<$Res> {
  __$MoneygramFeeResponseDtoCopyWithImpl(this._self, this._then);

  final _MoneygramFeeResponseDto _self;
  final $Res Function(_MoneygramFeeResponseDto) _then;

  /// Create a copy of MoneygramFeeResponseDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? bridgeFee = null,
    Object? moneygramFee = null,
    Object? gasFeeInUsdc = freezed,
    Object? priorityFee = freezed,
  }) {
    return _then(
      _MoneygramFeeResponseDto(
        bridgeFee:
            null == bridgeFee
                ? _self.bridgeFee
                : bridgeFee // ignore: cast_nullable_to_non_nullable
                    as String,
        moneygramFee:
            null == moneygramFee
                ? _self.moneygramFee
                : moneygramFee // ignore: cast_nullable_to_non_nullable
                    as String,
        gasFeeInUsdc:
            freezed == gasFeeInUsdc
                ? _self.gasFeeInUsdc
                : gasFeeInUsdc // ignore: cast_nullable_to_non_nullable
                    as String?,
        priorityFee:
            freezed == priorityFee
                ? _self.priorityFee
                : priorityFee // ignore: cast_nullable_to_non_nullable
                    as int?,
      ),
    );
  }
}

/// @nodoc
mixin _$FundXlmRequestDto {
  String get accountId;

  /// Create a copy of FundXlmRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $FundXlmRequestDtoCopyWith<FundXlmRequestDto> get copyWith =>
      _$FundXlmRequestDtoCopyWithImpl<FundXlmRequestDto>(this as FundXlmRequestDto, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is FundXlmRequestDto &&
            (identical(other.accountId, accountId) || other.accountId == accountId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, accountId);

  @override
  String toString() {
    return 'FundXlmRequestDto(accountId: $accountId)';
  }
}

/// @nodoc
abstract mixin class $FundXlmRequestDtoCopyWith<$Res> {
  factory $FundXlmRequestDtoCopyWith(
    FundXlmRequestDto value,
    $Res Function(FundXlmRequestDto) _then,
  ) = _$FundXlmRequestDtoCopyWithImpl;
  @useResult
  $Res call({String accountId});
}

/// @nodoc
class _$FundXlmRequestDtoCopyWithImpl<$Res> implements $FundXlmRequestDtoCopyWith<$Res> {
  _$FundXlmRequestDtoCopyWithImpl(this._self, this._then);

  final FundXlmRequestDto _self;
  final $Res Function(FundXlmRequestDto) _then;

  /// Create a copy of FundXlmRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? accountId = null}) {
    return _then(
      _self.copyWith(
        accountId:
            null == accountId
                ? _self.accountId
                : accountId // ignore: cast_nullable_to_non_nullable
                    as String,
      ),
    );
  }
}

/// @nodoc

class _FundXlmRequestDto implements FundXlmRequestDto {
  const _FundXlmRequestDto({required this.accountId});

  @override
  final String accountId;

  /// Create a copy of FundXlmRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  _$FundXlmRequestDtoCopyWith<_FundXlmRequestDto> get copyWith =>
      __$FundXlmRequestDtoCopyWithImpl<_FundXlmRequestDto>(this, _$identity);

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _FundXlmRequestDto &&
            (identical(other.accountId, accountId) || other.accountId == accountId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, accountId);

  @override
  String toString() {
    return 'FundXlmRequestDto(accountId: $accountId)';
  }
}

/// @nodoc
abstract mixin class _$FundXlmRequestDtoCopyWith<$Res> implements $FundXlmRequestDtoCopyWith<$Res> {
  factory _$FundXlmRequestDtoCopyWith(
    _FundXlmRequestDto value,
    $Res Function(_FundXlmRequestDto) _then,
  ) = __$FundXlmRequestDtoCopyWithImpl;
  @override
  @useResult
  $Res call({String accountId});
}

/// @nodoc
class __$FundXlmRequestDtoCopyWithImpl<$Res> implements _$FundXlmRequestDtoCopyWith<$Res> {
  __$FundXlmRequestDtoCopyWithImpl(this._self, this._then);

  final _FundXlmRequestDto _self;
  final $Res Function(_FundXlmRequestDto) _then;

  /// Create a copy of FundXlmRequestDto
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({Object? accountId = null}) {
    return _then(
      _FundXlmRequestDto(
        accountId:
            null == accountId
                ? _self.accountId
                : accountId // ignore: cast_nullable_to_non_nullable
                    as String,
      ),
    );
  }
}
